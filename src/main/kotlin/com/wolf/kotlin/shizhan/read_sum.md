对于开发人员而言， 编程语言的防危性（safety） 和安全性
（security） 是至关重要的。 要是有一门语言既能继承Java的所有优点及
其强大而完备的生态库， 又能更加简单、 安全和可控， 那真是再好不过
了。 我们很高兴地看到， Kotlin就是一门这样的语言


Kotlin是一种非研究性并且非常务实的工业级编程语言， 它的使命
就是帮助程序员解决实际工程实践中的问题。 使用Kotlin语言让Java程
序员的工作变得更轻松， Java语言中的那些空指针错误、 浪费时间的冗
长的样板代码、 啰嗦的语法限制等， 在Kotlin语言中统统消失。 Kotlin语
言简单、 务实， 语法简洁而强大， 安全且表达力强， 极富生产力。

Kotlin是一种基于JVM的静态类型编程语言

末尾的分号是可选的， 在大多数情况下， 编译器根据换行符就能够推
断语句已经结束

println()（虽然背后封装的仍然是Java
的System.out.println()方法

Kotlin为什么值得我们去学习？
与Java及JVM的完全互操作性；
多平台： 适合Android、 浏览器（JavaScript） 和本地系统编程
（native） ；
语法简洁不啰嗦（便于学习） ；
富于表现力和高效的生产力；
支持类型推断。 例如， 我们可以只写val number=23， 编译器会
推断这是一个Int；
可以使用数据类（data class） 以极简的方式创建POJO；
运算符重载相当简单；
快速、 方便地扩展内置类、 自定义类的函数与属性；
区分可空类型和不可空类型。 直接在编译期语法层面检查可空
类型， 提供空安全保障；
Kotlin含有功能丰富的集合类Stream API；
集成扩展了简单实用的文件I/O、 正则匹配、 线程等工具类；
提供了实用强大的函数式编程支持： 一等函数支持， Lambda表
达式、 高阶函数等；
能够轻松、 方便地创建DSL；
使用更加轻量级的协程进行并发编程；
IntelliJIDEA开发工具的一等支持；
Android开发有Android Studio 3内置原生支持；
提供的Anko库（https://github.com/Kotlin/anko） 使得Android开
发速度更快， 充满更多的乐趣等


Kotlin的优势是既有Java的完整生态（Kotlin完全无缝使用各类Java
API框架库） ， 又有现代语言的高级特性（语法糖）



Kotlin语言的特性
1.实用主义（Pragmatic）
务实、 注重工程实践性
2. 极简主义（Minimalist）
语法简洁优雅不啰嗦， 类型系统中一切皆是引用
（reference） 
3. 空安全（Null Safety）
有一个简单完备的类型系统来支持空安全
4.多范式（multi-paradigm）
同时支持OOP与FP编程范式。 各种编程风格的组合可以让我
们更加直接地表达算法思想和解决问题的方案， 可以赋予我们在思考上
有更大的自由度和灵活性
5.可扩展
可直接扩展类的函数与属性（extension functions &
properties）
一种非常注重用户体验的语言
6.高阶函数与闭包（higher-order functions & closures）
Kotlin的类型中， 函数类型（function type） 也是一等类型（first
class type） 。 在Kotlin中可以把函数当成值进行传递， 这直接赋予了
Kotlin函数式编程的特性
7.支持快速实现DSL
有了扩展函数、 闭包等特性的支持， 使用Kotlin实现一个DSL将会
相当简单、 方便

扩展函数与扩展属性的“好玩”之处在于， 可以在不修改原来类的条
件下自定义函数和属性， 使它们表现得就像是属于这个类一样

使用Kotlin编程比Java更加安全， 至少在空指针问题上写起代码来
会更加“开心”。 Kotlin中引入了不可空类型与可空类型来明确声明一个
变量是否可能为null， 同时在编译期通过类型是否匹配来检查空指针异
常， 大大降低了空指针异常出现的概率
var a :String
a=null// 报错
var a :String? 
使用方式：a?.lenth()


在Kotlin中函数是第一等类型（fist class） ： 我们可以将函数像值一
样传递， 函数可以作为另一个函数的返回值。 我们通常称之为“一等函
数（first order functions） ”支持

智能类型推断

我们认为Kotlin的定位是一种现代化工业语言： 它专注于代码重用
和可读性的弹性抽象， 以及面向早期错误侦测和明确捕获维护与清理的
意图这些问题的静态类型安全性

Kotlin旨在成为一种面向工业的面向对象语言， 而且是一种比Java
更好的语言， 但仍然可以与Java代码完全互操作， 允许企业逐步从Java
迁移到Kotlin，这就是兼容的好处


编程的真正问题在于， 如何把人类脑子里对问题的解决方案“具
化”到机器世界， 而这个“具化”的过程正是编程语言所要表达的东西。
如何富有表现力并且安全简洁地表达， 这是所有编程语言所要解决的问
题。 让人类能够尽可能“自然地”和计算机进行沟通交流， 这一直是促使
人们提高编程语言抽象层次的主要目标之一

Kotlin设计了一个“归一化”的类型系统（一切类型皆是引用类
型） ， 纯天然地设置了一道空指针的屏障， 使得Kotlin比Java更加安全
可靠。 Kotlin还引入了类型推断、 一等支持函数式编程、 Lambda、 高阶
函数、 类的扩展函数与属性、 DSL等诸多特性， 使得我们可以编写简单
且高效的代码， 更加专注地投入到业务逻辑的实现上

优秀的程序员当然会选择使用Kotlin这些更加先进的特性， 因为它
们有助于更直接地表达观点， 而且也没有额外的开销， 何乐而不为呢？

现在的编程语言已经足够多了， 为什么我们还需要更多的语言？
Java已经足够强大了， 为什么我们还需要Kotlin、 Scala这样的语言呢？
其实， 如果我们仔细想想， 会发现这个问题本身的逻辑就不成立。
例如， 我们能这样说吗——煎鸡排已经足够好吃了， 为什么我们还要去
吃煎牛排呢？

一种思路： 程序完全可以在不同的层
次上编制！ 


Java语言也有不好的一面， 简单列举如下
1. 检查异常（Checked Exceptions）
2. 基本类型和数组
比较好的方案是， 源代码不
用直接使用基本类型或者数组， 由编译器（或者JVM） 来决定是否可以
帮你对其进行优化， 而Kotlin正是这么做的
3. 静态变量（Static）
静态方法经常会导致需要显式地定义接口， 从而使得API更加复
杂。 一个更好的办法就是采用单例对象， 单例对象在大多数情况下的表
现与静态对象差不多， 但是可以像一个对象一样被传递。 Kotlin中提供
了object单例对象
4. 泛型
这个问题在Effective Java一书中提出了
PECS（Producer Extends Consumer Super） 的建议， Kotlin直接使用了这
个方案
5. 空指针异常（NPE）
Kotlin中引入了可空类型与安全调用符、 Elvis操作符等特性来实现空安
全
6. 一堆getter/setter单调冗长的样板代码
在Kotlin中我们可以使用数据类
7. 不容易传递函数
在Kotlin中
直接提供了一等函数类型（First-Class Function Type） ， 其跟普通类型
一样， 函数类型可以作为值来传递， 也可以作为返回值


计算机中的所有问题， 都可以通过向上抽象封装一层来解决

我们经常说的Java语言是平台无关的， 即跨平台的， 其实针对从
Java、 Scala、 Kotlin、 Groovy等的源代码到JVM字节码这一层是平台无
关的


在下一代普遍可接受语言（next mass-appeal language） 中， 人的因
素应该是至关重要的。 在功能方面， 应该具备如下特性：
类C的语法（容易被大众程序员所接受， 很好用也很熟悉） ；
静态类型（动态类型过于松散并且性能有限， 不适用于大型项
目） ；
遵循面向对象程序设计OOP思想， 同时支持函数式编程
（FP） ；
反射（从而避免静态类型限制） ；
属性（getter和setter实在是太让人讨厌了） 
高阶函数， Lambda与闭包；
Null判断（提供一个判断变量能否为null的方式） ；
并发协程；
模块化；
完善的工具支持；
可扩展性（语言的设计具备很好的可扩展性） ；


生命只有一次， 所以不要去做一些重复无聊的事情。 能交给计算机
做的， 就尽量交给计算机去做。

解决问题的复杂程度直接取决于抽象的种类及质量。 将结构、 性质
不同的底层实现进行封装， 向上提供统一的API接口， 让使用者觉得就
是在使用一个统一的资源， 或者让使用者觉得自己是在使用一个底层不
直接提供而“虚拟”出来的资源。

在Kotlin中， 所有的变量类型都是引用类型。 Kotlin的变量分为
val（不可变的） 和var（可变的） 

应尽量在Kotlin中首选使用val不变值。 因为在程序中大
部分地方只需要使用不可变的变量， 而使用val变量可以带来可预测的
行为和线程安全等优点

协变逆变修饰符
in 消费者类型修饰符，out T等价于? extend
out 生产者类型修饰符，in T等价于? super T

reified 具体化类型参数

Kotlin语言也是“静态类型的编程语
言”。

通常， 编程语言中的类型系统中定义了：
如何将数值和表达式归为不同的类型；
如何操作这些类型；
这些类型之间如何互相作用。


在编程语言中使用类型的目的是为了让编译器能够确定类型所
关联的对象需要分配多少空间

静态类型在编译时期就能可靠地发现类型错误，
因此通常能增进最终程序的可靠性


定型（typing， 又称类型指派） 的过程就是赋予一组比特以具体的意义。 
类型通常和存储器中的数值或对象（如变量） 相联系。 
因为在计算机中， 任何数值都是由一组简单的比特位组成的， 硬件无法区分存储器地址、 脚本、 字符、 整数及浮点数。 
类型可以告知程序和程序设计者， 应该怎么对待那些比特位

有了类型， 我们还可以更好地做抽象化、 模块化的工作。 这使得我
们可以在较高抽象层次思考并解决问题。 例如， Java中的字符数组
char[]s={'a','b','c'}和字符串类型String str="abc"就是最简单、 最典型的抽
象封装实例


Kotlin中去掉了原始类型， 只有包装类型， 编译器在编译代码的时
候， 会自动优化性能， 把对应的包装类型拆箱为原始类型


Kotlin系统类型分为可空类型和不可空类型。 Kotlin中引入了可空类
型， 把有可能为null的值单独用可空类型来表示

对于Kotlin中的数字类型而言， 不可空类型与Java中原始的数字类型对应
Kotlin中对应的可空数字类型就相当于Java中的装箱数字类型
在Kotlin中非空数字类型Int到可空数字类型Int?需要进行装
箱操作。 同时， 非空的Int类型会被编译器自动拆箱成基本数据类型int，
存储的时候也会存到栈空间

Kotlin简单直接地使用Array类型代表数组类型
常用的是boolean[]、 char[]、 byte[]、 short[]、 int[]、
long[]、 float[]、 double[]； Kotlin直接使用了8个新的类型来对应这样的编程场景：
BooleanArray
ByteArray
CharArray
DoubleArray
FloatArray
IntArray
LongArray
ShortArray


Kotlin也是面向表达式的语言。 在Kotlin中所有控制流语句都是表达
式（除了变量赋值、 异常等） 

Unit与Nothing之间的区别是， Unit类型表达式计算结果的返回
类型是Unit; Nothing类型的表达式计算结果是永远不会返回的（与
Java中的void相同）


就像Any是在非空类型层次结构的根一样， Any?是可空类型层次的 根。 
Any?是Any的超集， Any?是Kotlin类型层次结构的最顶端

由于没有封
装机制， 那个时候的变量都是“全局变量”， 因此会不可避免地经常出现
变量名冲突问题


面向对象编程思想主要是复用性和灵活性（弹性）
灵活性主要是应对变化的特性， 因为客户的
需求是不断改变的， 怎样适应客户需求的变化， 是软件设计灵活性或者
说是弹性的问题


Java是一种面向对象编程语言， 它基于Smalltalk语言， 作为OOP语
言， 它具有以下5个基本特性
万物皆对象， 每一个对象都会存储数据， 并且可以对自身执行
操作。 因此， 每一个对象包含两部分： 成员变量和成员方法。
在成员方法中可以改变成员变量的值。
程序是对象的集合， 他们通过发送消息来告知彼此所要做的事
情， 也就是调用相应的成员函数。
每一个对象都有自己的由其他对象所构成的存储， 也就是说在
创建新对象的时候可以在成员变量中使用已存在的对象
每个对象都有其类型， 每个对象都是某个类的一个实例， 每一
个类区别于其他类的特性就是可以向它发送什么类型的消息，
也就是它定义了哪些成员函数。
某一个特定类型的所有对象都可以接受同样的消息。 另一种对
对象的描述为： 对象具有状态（数据， 成员变量） 、 行为（操
作， 成员方法） 和标识（成员名， 内存地址） 

在面向对象编程中， 一个理想的对象应该是只暴露它的抽象接口
（纯表面， 无“体积”） ， 其方法则扮演“箭头”的角色。 如果为了理解一
个对象如何与其他对象进行复合， 而不得不深入挖掘对象的实现之时，
你所用的编程范式的优势就荡然无存了。

面向对象编程是一种编程思想， 相比于早期的结构化程序设计， 其
抽象层次更高， 思考解决问题的方式也更加贴近人类的思维方式

对象提供
了一种处理复杂性的方式
有了对象， 我们能够通过提升抽象级别来构建更大、 更复杂的
系统，底层都是进行抽象都是对为上层提供更好的服务

面向对象编程以现实世界中的事物（对象） 为中心来思考问题， 认
识问题， 并根据这些事物的本质特征， 把它们抽象表示为系统中的类。



面向对象编程基于类编程， 更加贴近人类解决问题的习惯方法， 让
软件世界更像现实世界。 面向对象编程通过抽象出关键的问题域来分解
系统。 对象不仅能表示具体的事物， 还能表示抽象的规则、 计划或事
件。

抽象类表示“is-a”的关系， 而接口所代表的是“has-a”的关系。
抽象类用来表征问题领域的抽象概念
机器语言是对机器的模仿抽象， 汇编语言是对机器语言的高层次抽
象， 高级语言（Fortran、 C、 BASIC等） 是对汇编的高层次抽象。 面向对象编程语言是对过程函数的高层次封装

抽象是相对于具象而言的


当子类继承了某个类之后， 便可以使用父类中的成员变量， 但并不
是完全继承父类的所有成员变量。 具体的原则如下：
能够继承父类的public和protected成员变量；
不能继承父类的private成员变量；
对于父类的包访问权限成员变量， 如果子类和父类在同一个包
下， 则子类能够继承； 否则， 子类不能继承；
对于子类可以继承的父类成员变量， 如果在子类中出现了同名
称的成员变量， 则会发生隐藏现象， 即子类的成员变量会屏蔽
掉父类的同名成员变量。 如果要在子类中访问父类中的同名成
员变量， 需要使用super关键字进行引用


接口是一种比抽象类更加抽象的“类”。 接口本身代表的是一种“类
型”的概念

接口是用来建立类与类之间的协议

reified是具体化类型关键字
@PureReifiable注解用来指定对应的类型参数不能用于不安全操作， 如强制转换或is检查。 这意味着使用泛型类型作为参数是完全安全的

函数式编程语言最重要的基础是λ演算（lambdacalculus） ， 而且λ演
算的函数可以传入函数参数， 也可以返回一个函数。 函数式编程（简称
FP） 是一种编程范式（programming paradigm）

函数式编程与命令式编程最大的不同是： 函数式编程的焦点在于数
据的映射， 命令式编程（imperative programming） 的焦点是解决问题的
步骤

函数式编程的本质是函数的组合

函数式编程是简单、 自然、 直观易懂且美丽、 “优雅”的
编程风格。 函数式编程语言中通常都会提供常用的map、 reduce、 filter
等基本函数， 这些函数是对List、 Map集合等基本数据结构的常用操作
的高层次封装， 就像一个更加智能、 好用的工具箱

函数式编程是关于不变性和函数组合的编程范式。 

函数式编程有如下特征
1.一等函数支持（first-class function） ： 函数也是一种数据类
型， 可以作为参数传入另一个函数中， 同时函数也可以返回一
个函数
2.纯函数（pure function） 和不变性（immutable） ： 纯函数指的
是没有副作用的函数（函数不去改变外部的数据状态）
在函数式编程中，
倾向于使用纯函数编程。 正因为纯函数不会去修改数据， 同时
又使用不可变的数据， 所以程序不会去修改一个已经存在的数
据结构， 而是根据一定的映射逻辑创建一份新的数据。 函数式
编程是转换数据而非修改原始数据
3.函数的组合（compose function） ： 在面向对象编程中是通过对
象之间发送消息来构建程序逻辑的； 而在函数式编程中是通过
不同函数的组合来构建程序逻辑的


在Kotlin里,可以自由扩展任
何类的方法和属性。 在不修改原类的情况下， Kotlin能给一个类扩展新
功能而无须继承该类

Kotlin中提供了使用非常简单的扩展函数功能。 我们可以为现有的
类自由添加自定义的函数。

扩展属性和扩展函数的本质是以静态导入的方式来实现的

为了表示当前函数的接收者
（receiver） ， Kotlin中使用this表达式：
在类的成员函数中， this指向这个类的当前对象实例；
在扩展函数中， 或带接收者的函数字面值（function literal）
中， this代表调用函数时， 在点号左侧传递的接收者参数；
如果this没有限定符， 那么它指向包含当前代码的最内层范
围。 如果想要指向其他范围内的this， 需要使用标签限定符

编程技巧提示： 可以新建一个公共源文件， 把自定义的扩展属性和扩
展函数都放到包中， 作为一个通用工具类来使用


集合类存放的都是对象的引用， 而非对象本身， 我们通常说的集合中的对象指的是集合中对象的引用（reference)
集合类主要有3种： List（列表） 、 Set（集） 和Map（映射） 

List列表分为只读不可变的List和可变MutableList（可写入、 删除数
据）
Set集也分为不可变Set和可变MutableSet（可写入、 删除数据） 。
Kotlin中的Map与List、 Set一样， Map也分为只读Map和可变
MutableMap（可写入、 删除数据） 


在集合类的场景下， 我们通常需要编
写可以应用于多种类型的代码,能不能把“类型”也抽象成参数呢

泛型机制实现了“参数化类型”（Parameterized
Type） 。 参数化类型， 顾名思义就是将类型由原来的具体类型参数化，
类似于方法中的变量参数， 此时类型也定义成参数形式， 我们称之为类
型参数， 然后在使用时传入具体的类型（类型实参）

将这个元素类型String的信息存放到一个“类型参数”中， 然后
在编译器层面引入相应的类型检查和自动转换机制， 这样就可以解决类
型安全使用的问题了。 这也正是引入泛型的基本思想。
泛型最主要的优点就是让编译器追踪参数类型， 执行类型检查和类
型转换

泛型类、 泛型接口和泛型方法具备可重用性、 类型安全和高效等优
点。


Java和Kotlin的泛型实现， 都是采用了运行时类型擦除的方式。 也
就是说， 在运行时， 这些类型参数的信息将会被擦除。
泛型是在编译器层次上实现的， 生成的class字节码文件中是不包含
泛型中的类型信息的。 JVM看到的只是List，
而由泛型附加的类型信息对JVM来说是不可见的


类型擦除的基本过程也比较简单：
首先， 找到用来替换类型参数的具体类。 这个具体类一般是
Object。 如果指定了类型参数的上界的话， 则使用这个上界。
其次， 把代码中的类型参数都替换成具体的类。 同时去掉出现
的类型声明， 即去掉<>的内容。
最后， 根据需要生成一些桥接方法。 这是由于擦除了类型之后
的类可能缺少某些必须的方法。 这个时候就由编译器来动态生
成这些方法。

是编译器承担了全部的
类型检查工作。 编译器禁止某些泛型的使用方式， 也正是为了确保类型
的安全性


Kotlin的原则就是Java已经有
的好用的类就直接使用， 没有的或者不好用的类， 就在原有类的基础上进行功能扩展


Kotlin的基本原则： 充分使
用已有的Java生态库， 在此基础之上进行更加简单、 实用的扩展， 大大
提升程序员的工作效率。 从本章的介绍中我们也体会到了Kotlin编程中
的极简理念——不断地抽象、 封装、 扩展， 使之更加简单、 实用。


DSL（Domain-Specific Language， 领域特定语言） 指的是专注于特
定问题领域的计算机语言。 不同于通用的计算机语言（GPL） ， 领域特
定语言只用在某些特定的领域

DSL语言能让我们以一种更优雅、 更简洁的方式来表达和解决领域
问题。 之所以能够这样， 是因为DSL语言刚好能够用于这个特定的解决
领域中存在的模式

DSL简单讲就是对一个特定问题（受限的表达能力） 的方案模型更
高层次的抽象表达（领域语言） ， 使其更加简单易懂（容易理解的语义
及清晰的语义模型） 

DSL只是问题解决方案模型的外部封装， 这个模型可能是一个API
库， 也可能是一个完整的框架等。 DSL提供了思考特定领域问题的模型
语言， 这使得我们可以更加简单、 高效地解决问题。 DSL聚焦一个特定
的领域， 简单易懂， 功能极简但完备， 更加方便我们理解和使用模型。


相比XML风格的DSL（XML本质上讲也是一种DSL） ， 使用原生
的编程语言（如Kotlin） DSL风格更加简单、 干净， 也更加自由、 灵
活

可以将foo.invoke()简写成foo()， 在Kotlin中操作符是可
以重载的， “()”操作符对应的就是类的重载操作符函数invoke

使用DSL的代码风格， 可以让我们的程序更加直观易懂、 简洁优
雅。 使用Kotlin实现一个DSL非常简单， 而且相当实用

通常一门编程语言中都会内置预定义的运算符（如+、 -、 *、 /、
==、 !=等） ， 这些运算符的操作对象只能是基本数据类型

在实际的
编程场景中有很多自定义类型， 其实也有类似的运算操作。 这就是我们
通常所说的运算符重载（overload） 

运算符重载是对已有的运算符赋予新的含义， 使同一个运算符作用
于不同类型的数据会有对应这个数据类型的行为

运算符重载的实质是函数重载， 本质上是对运算符函数的调用， 从
运算符到对应函数的映射过程由编译器完成。 由于一般数据类型间的运
算符没有重载的必要， 所以运算符重载主要是面向对象之间的

Kotlin中的运算符重载约定定义在
org.jetbrains.kotlin.util.OperatorNameConventions中

运算符与操作符函数的映射关系定义在
org.jetbrains.kotlin.types.expressions.Operator Conventions.java中
其中， KtTokens.kt中定义了+、 -、 *、 /、 ==、 !、 ++、 --、 *=、 /=等
运算符的符号

有了操作符重载， 我们可以将两个对象加起来变成另外一个对象

运算符重载其实是Kotlin的一个语法糖,a+b经过反编译后就是调用plus

Kotlin在编译器层面做了大量工
作， 就是为了让代码更简洁， 让编译器处理更多的事情。 毋庸置疑的是
Kotlin的简洁优雅而且强大实用的语法和各种各样的语法糖可以大大地
提升程序员的工作效率


Ko
tlin中使用operator fun声明重载运算符函数

Kotlin通过更高层次的封装， 大大简化了BigDecimal数
据类型的算术运算的代码， 使得BigDecimal算术运算的代码更加简单、易读

在Kotlin中一切类型都是
引用类型

“==”会映射成调用equals(Object x)方法
就算a、 b是null， 也可以安全调用。 因为a==b会被
Kotlin编译器翻译成带可空性判断的equals()方法的调用， 即
a?.equals(b)?:(b ===null)。

“===”是Kotlin中自己实现的运算符， 这个运算符不能
被重载， 它不仅会比较值是否相等， 还会去比较对象的引用是否相等

在进行对象之间的运算时， 编译器解析的时候会去调用对应运算符
重载函数


反射（Reflection） 是在运行时获取类的函数（方法） 、 属性、 父
类、 接口、 注解元数据、 泛型信息等类的内部信息的机制。 这些信息称
之为RTTI（Run-Time Type Information， 运行时类型信息）

注解（Annotation） 是我们给代码添加的元数据

Meta-前缀在西方哲学界是指： 关于事物自身的事物

元编程（Meta-programming） 是指用代码在编译期或运行期生成或
改变代码的一种编程形式
编写元程序的语言称之为元语言， 被操纵的语言称之为目标语言。 如果一门语言中具备同时是元语言也是目标语言
的能力， 这就是反射

一般代码的操作对象是数据， 元编程操作的对象是其他代码， 无关
业务逻辑， 只跟当前代码结构相关的代码

元编程本质上是一种对源代码本身进行高层次抽象的编码技术。 元
编程比我们手写的代码多提供了一个抽象层次！

XML配置就是为了分离
代码和配置而引入的， 而注解是为了希望使用一些和代码紧耦合的东
西。 事物的发展就是这样阴阳交合、 辩证发展的过程。

注解是将元数据附加到代码的方法。 而反射可以在运行时把代码中
的注解元数据获取到， 并在目标代码执行之前进行动态代理， 实现业务
逻辑的动态注入， 这其实就是AOP（Aspect Oriented Programming， 面
向切面编程（也叫面向方面） ） 的核心思想——通过运行期动态代理
（和预编译方式） 实现在不修改源代码的情况下， 给程序动态添加新功
能的一种技术

自定义的注解中使用的注解（例如@Target、 @Retention等） ， 称
之为元注解（Meta-annotation）

反射是指在运行时（Run Time） ， 程序可以访问、 检测和修改它本
身状态或行为的一种能力。 Kotlin中的函数和属性也是头等公民， 我们
可以通过反射来内省属性和函数， 如运行时属性名或类型， 函数名或类
型等









































kotlin实战

简洁、安全、实用语言
发明者是JetBrains
还犹豫什么，请立即使用她们
学习一门编程语言是一个令人兴奋且常常是汇报颇丰的尝试。会使你以新的术语来思考熟悉的东西，从而以更高层次的抽象来更深入地了解他们。
www.manning.com/books/kotlin-in-action

kotlin是一种针对java平台的新编程语言，简洁、安全、务实，专注于与java代码的互操作性。

首要目标是提供一种更简洁、更高效、更安全的替代 Java 的语言，并
且适用于现今使用 Java 的所有环境

使用 Kotiin 可以帮
助开发者在实现目标的同时减少代码并避免麻烦。

Kotlin 和 Java 一样是一种静态类型的编程语言。这意味着所有表达式的类型在
编译期已经确定了，而编译器就能验证对象是否包含了你想访问的方法或者宇段。

编译器这种从上下文推断变量类型的能力被称作类型推导

静态类型带来的好处：
性能一一方法调用速度更快，因为不需要在运行时才来判断调用的是哪个方法 。
可靠性一一编译器验证了程序的正确性，因而运行时崩溃的概率更低。
可维护性一一陌生代码更容易维护，因为你可以看到代码中用到的对象的类型 。
工具支持一一静态类型使 IDE 能提供可靠的重构、精确的代码补全以及其他
特性 。


函数式编程的核心概念
头等函数一一把函数（ 一小段行为）当作值使用，可以用变量保存它，把它
当作参数传递，或者当作其他函数的返回值 。
不可变性一一使用不可变对象，这保证了它们的状态在其创建之后不能再变
化 。
无副作用一一使用的是纯函数。此类函数在输入相同时会产生同样的结果 ，
并且不会修改其他对象的状态， 也不会和外面的世界交互。


函数式编程风格的代码能给你带来什么好处？
1.简洁。函数式风格的代码
比相应的命令式风格的代码更优雅、更简练，因为把函数当作值可以让你获得更强
大的抽象能力，从而避免重复代码。
可以使用一种简洁的语法来表示这些匿名函数，它被称作 lambda
表达式：
2.多线程安全。使用的是不可变数据结构和纯函数，就能保证这样不安全的修改根
本不会发生，也就不需要考虑为其设计复杂 的同步方案。
3.测试更加容易。没有副作用的函数可以独立地进行测
试，因为不需要写大量的设置代码来构造它们所依赖的整个环境

Kotlin 使用的两个主要的领域是服务器端和 Android 开发

Kotiin 的一大优势就是它与现有的 Java 代码无缝的互操作性

Kotlin 的类型系统通过精确地
跟踪 null 值，大大减轻了空指针异常问题带来的压力


Katlin的设计哲学
是一门务实、简洁和安全的语言，专注于
互操作性

Kotiin 就是一门设计出来解决现实世界问题的实用语言。它的设计基于多年创建大型系统的工业经验，它的特性也是为
解决许多软件开发者遇到的场景而选择的 。Kotiin 能够帮助解决实际项目的问题。

代码越简单越简洁，你就能越快地了解发生了什么

如果语言的语
法清晰地表达了被阅读的代码的意图，没有因为达成意图所需的样板代码而晦涩难
懂，那么它就是简 洁的 。

越简洁的代码写起来花的时间越短，更重要的是，读起来耗费的时间也更短 。
这会提高你的生产力并让你更快地达成目标。

java与kotlin相互操作无障碍

尝试一下 Koti in

Kotlin 也是编译型语言。这意味着你必须先编译，然后才能执行
Kotl in 代码

Kotiin 的源代码存放在后缀名为 .kt 的文件中。 Kotiin 编译器会分析源代码井
生成 . class 文件

从命令行编译代码，然后就可以用 j ava 命令执行你的代码：
kotlinc <source file or directory> -include-runtime -d <jar name>
java Jar <Jar name>

用 Kotiin 编译器编译的代码依赖 Katlin 运行时库

可以先用 Java 写出相应的代码片段，然后把它粘贴到 Kotlin 文件中，
转换器会自动地将代码转换成 Kotlin

语句和表达式的区别在于:
表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码
块中的顶层元素，并且没有自己的值


使用不可变引用、不可变对象及无副作用的函数让你的代码更
接近函数式编程风格

在 Kotlin 中，属性是头等的语言特性，完全代替了字段和访问器方法

通常来说，如
果描述的是类的特征（属性），应该把它声明成属性。

Kotlin 的区间是包含的或者闭合的，意味着第二个值始终是区间的一部分

Kotlin 并不区分受检异常和未受检异常。不用
指定函数抛出的异常 ， 而且可以处理也可以不处理异常

继续阅读本书 ， 你会不断学习怎样改变你习惯的思考
方式，发挥出新语言的全部能量。

当你从 Java 中调用 Kotlin 函数的时候，
必须显式地指定所有参数值
可以用＠ JvmOverloads 注解它 。这个指示编译
器生成 Java 重载函数，从最后一个开始省略每个参数。

在 Kotlin 中，根本就不需要去创建这些无意义的类 。 相反，可以把这些函数直
接放到代码文件的顶层，不用从属于任何的类

扩展函数非常简单，它就是一个类的成员函数，不过定义在类的
外面

实质上，扩展函数是静态函数，它把调用对象作为了它的第一个参数

扩展函数并不是类的一部分，它是声明在类之外的

如果一个类的成员函数和扩展函数有相同的签名，成员函数往往会被
优先使用

Kotlin 的声明默认是 final 和 public 的

internal ，表示“只在模
块内部可见飞一个模块就是一组一起编译的 Kotiin 文件

Kotlin 的嵌套类
不能访问外部类的实例，除非你特别地做出了要求

为父类添加一个 sealed
修饰符，对可能创建的子类做出严格的限制。所有的直接子类必须嵌套在父类中


主构造方法（通常是主要而简洁的初始化类的方法，
并且在类体外部声明）和从构造方法（在类体内部声明〉 。

不要声明多个从构造方法用来重载和提供参数的默认值。 取而代之
的是，应该直接标明默认值。

如果类没有主构造方法，那么每个从构造方法必须初始化基类或者委托给另一
个这样做了的构造方法。每个从构造方法必须以一个朝外的箭头开
始井且结束于任意一个基类构造方法。

object 关键字在多种情况下出现，但是它们都遵循同样的核心理念 ：
这个关键字定义一个类并同时创建一个实例
不同场景 ：
· 对象声明是定义单例的 一种方式。
· 伴生对象可以持有工厂方法和其他与这个类相关，但在调用时并不依赖类实
例的方法 。 它们的成员可以通过类名来访问 。
· 对象表达式用来替代 Java 的匿名内部类。


类的伴生对象会同样被编译成常规对象：类中的一个引用了它的实例的静
态字段


Lambda 表达式，或简称 lambda ，本质上就是可以传递给其他函数的一小段代码 。

函数式编程提供了另外一种解决问题的方法：把函数当作值来对待。可 以直接
传递函数，而不需要先声明一个类再传递这个类的实例

可以高效地直接传递代码块作为函
数参数。

良好编程风格的主要原则之一是避免代码中 的任何重复

Kotlin 的 lambda 表达式始终用花括号包围。注意实参并没有用括号括起来 。 箭
头把实参列表和 lambda 的函数体隔开。

你是否需要在方法中增加对
null 的检查呢？这取决于使用该函数的意图。

Kotlin 的可空类型为这类问题提供了全面的解决方案。区分开可空类型和非空
类型使事情变得明朗：哪些对值的操作是允许的，哪些操作有会导致运行时异常并
因此被禁止。
直接让程序员关注，是否为空

在实现 Java 类或者接口的方法时一定要搞清楚它的可空性

Katlin 并不区分基本数据类型和它们的包装类

在运行时，数字类型会尽可能地使用最高效的方式来表示 。 大多数情况下一一
对于变量、属性、参数和返回类型一－Katlin 的 Int 类型会被编译成 Java 基本数据
类型 int 。 唯一不可行的例外是泛型类，比如集合

Kotlin 中的可空类型不能用 Java 的基本数据类型表示
只要使用了基本数据类型的可空版
本，它就会编译成对应的包装类型

泛型类是包装类型应用的另一种情况。如果你用基本数据类型作为
泛型类 的类型参数，那么 Kotlin 会使用该类型的包装形式
泛型类 CJava 和 Kotiin 一样〉必须始终使用类型的包装表示

Kotiin 不会自 动
地把数字从一种类型转换成另外一种
为了避免意外情况 ， Kotlin 要求转换必须是显式的

Any 类型是 Kotiin 所有非空类
型的超类型（非空类型 的根 〉
在底层， Any 类型对应 java.lang.Object

Koti in 中的 Unit 类型完成了 Java 中的 void 一样的功能

只存在一个值是 Unit 类型，这个
值也叫作 Unit，并且（在函数中）会被隐式地返回

在函数式编程语言中， U口工 t 这个名字习惯上被用来表示“只有一个实例”，

把访问集合数据的接
口和修改集合数据的接口分开了
kotlin .collections.Collection --读
kotlin.collections . MutableCollection--写
一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合
的地方使用可变接口 的变体

必须了解只读集合并不总是线程安全的，给你返回只读，还可能给别人用可修改接口

每一个 Kotlin 接口都是其对应 Java 集合接口的一个实例

每一种 Java 集合接口在 Kotlin 中都有两种表示： 一种是只读的，另 一种是可变

Kotlin 把那些定义
在 Java 代码中的类型看成平台类型
Kotiin 没有任何关于平台类型的可空性信息，
所以编译器允许 Kotlin 代码将其视为可空或者非空。

数纽类型的类型参数始终会变成对象类型 。 因此，如果你声
明了 一个 Array< Int ＞ ，它将会是一个包含装箱整型的数组
如果你需要创建没有装箱的基本数据类型的数组，必
须使用一个基本数据类型数组的特殊类，如IntArray

Java 中的类型在 Koti in 中被解释成平台类型，允许开发者把它们当作可空或
非空来对待

Kotlin 的 Ar ray 类就像普通的泛型类 ， 但它会被编译成 Java 数组 。

Kotiin 也有许多特性的原理非常类似，通过调用自己代码中定义的函数，来实
现特定语言结构
这些功能与特定的函数命名相关，而不是与
特定的类型绑定，如plus函数对应+
把这种
技术称为约定

一般来说，最好一致地设计出新的类：
尽量不要同时给一个类添加 p lu s 和 plusAssign 运算
如产生新类则用plus，若是变动内部则用plusAssign

等运算符（＝＝＝与 Java 中的＝＝运算符是完全相同的：检查两个参数是否是同一个对象
的引用

不用过早地担心性能问题，除非你
知道这个实现将会被频繁调用。

高阶函数就是以另 一个函数作
为参数或者返回值的函数

在 Kotiin 中 ， 函数可以用 lambda 或者函数引用来表示
Unit 类型用于表示函数不返回任何有用的值

函数作为参数的背后原理，函数类型被声明为普通 的接口： 一个函数类型的变量是
Functio nN 接口的一个实现

函数类型是一个包含
invoke 方法的接口的具体实现

高阶函数是一个改进代码结构和减少重复代码的利器

函数类型可以帮助去除重复代码。如果你禁不住复制粘贴了 一段代码，那么很
可能这段重复代码是可以避免的。使用 lambda，不仅可以抽取重复的数据，也可以
抽取重复的行为。

如果使用 inline 修饰符标
记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函
数实现的真实代码替换每一次的函数调用
当一个函数被声明为 in line 时，它的函数体是内联的一一换句话说，函数体
会被直接替换到函数被调用的地方，而不是被正常调用

当函数被内
联的时候，作为参数的 lambda 表达式的函数体会被直接替换到最终生成的代码中
一般来说，参数如果被直接调用或者作为参数传递给另外一个 inline 函数，
它是可以被内联的 。否则，编译器会禁止参数被内联并给出错误信息“ Illegal usage
of inline-parameter”（非法使用内联参数）。

在 Kotlin 中， filter 函数被声明为内联函数。这意味着 filter 函数，以及传
递给它的 lambda 的宇节码会被一起内联到 filter 被调用的地方

filter+map直接用于集合则由于inline则内联，但是会有中间集合产生，若量大则有幸能问题，应该用序列，但是用序列时，由于
是惰性操作所以会有中间变量表示lambda并不会内联。所以asSEquence只在处理大量数据的集合时有用，小的集合可以用
普通的集合操作处理。

使用
inline 关键字只能提高带有 lambda 参数的函数的性能，其他的情况需要额外的度
量和研究。
在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内
联的函数很大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。
在 Kotlin 标准库中的内联函数总是很小的

泛型允许你定义类型,可以带类型形参
当这种类型的实例被创建出来的时候，类
型形参被替换成称为类型实参的具体类型

类型参数约束可以限制作为（泛型）类和（泛型）函数的类型实参的类型

一旦指定了类型形参 T 的上界，你就可以把类型 T 的值当作它的上界（类型 ）
的值使用

JVM 上的泛型一般是通过类型擦除实现的，就是说泛型类实例的
类型实参在运行时是不保留 的

Kotlin 的泛型在运行时也被擦除了 。这意味着泛型类实例不会携
带用于创建它的类型实参的信息

因为类型实参没有被存储下来 ，
你不能检查它们

注意擦
除泛型类型信息是有好处的：应用程序使用的内存总量较小，因为要保存在 内存中
的类型信息更少。

内联函数。内联函数
的类型形参能够被实化，意味着你可以在运行时引用实际的类型实参

为了保证良好的性能，你仍然需要跟踪了解标记为 inline 的函数的大小。如
果函数变得庞大，最好把不依赖实化类型参数的代码抽取到单独的非内联函数中


可以用实化类型参数：
· 用在类型检查和类型转换中（ is 、！ is 、 as 、 as?)
· 使用 Kotlin 反射 API ，我们将在第 10 章讨论（：： class)
． 获取相应的 j ava . lang . Class (: : class . java)
· 作为调用其他函数的类型实参

不能做下面这些事情：
· 创建指定为类型参数的类的实例
· 调用类型参数类的伴生对象的方法
· 调用带实化类型参数函数的时候使用非实化类型形参作为类型实参
．把类、属性或者非内联函数的类型参数标记成 reified


可以通过根据列表是否可变选择合适的接口来轻易地控制。
如果函数接收的是只读列表，可以传递具有更具体的元素类型的列表 。 如果列表是
可变的，你就不能这样做。

类型和类不一样
非泛型类，类的名称可 以直接当作类型使用
var x : String，就是声明了 一个可以保存 String 类的实例的变量
同样的类名称也可以用来声 明可空类型 ： var x : String ？

泛型类的情况，要得到一个合法的类型，需要用一个作
为类型实参的具体类型替换（泛型）类的类型形参
List 不是 一个类型（它
是一个类），但是下面列举 出来的所有都是合法的类型 ： List<Int ＞、
List <Str ing ？＞、 List<List<String ＞＞等 。每一个泛型类都可能生成潜在的
无限数量的类型。

任何时候如果需要的是
类型 A 的值，你都能够使用类型 B 的值（当作 A 的值） ， 类型 B 就称为类型 A 的子类型。
如果 A 是 B 的子类型，那么 B 就是 A 的超类型。

只有值的类型是变量类型的子类型时，才允许变量存储该值

一个非空类型是它的可空版本的子类型，但它们都对应着同一个类

能
在可空类型的变量中存储非空类型的值，但反过来却不行

一个泛型类一一例如 ， MutableList一一如果对于任意两种类型 A 和 B,
MutableList<A＞既不是 MutableList<B ＞ 的子类型也不是它的超类型，它 就
被称为在该类型参数上是不变型的

个类， List ，对它来说，子类型化规则不一样 。
Kotlin 中的 List 接口表示的是只读集合。如果 A 是 B 的子类型，那么 List <A>
就是 List<B＞的子类型。这样的类或者接口被称为协变的

一 个协变类是 一 个泛型类（我们以 Producer < T＞为 例〉，对这种类 来
说，下面的描述是成立的：如果 A 是 B 的子类型，那么 Producer<A＞就是
Producer < B ＞的子类型。我们说子类型化被保留了
例如 ， Pr oducer<Cat ＞是
Producer<Animal ＞的子类型 ， 因为 Cat 是 Animal 的子类型

// 要声明类在某个类型参数上是可以协变的，在该类型参数的名称前加上 out 关键字即可

将一个类的类型参数标记为协变的，在该类型实参没有精确匹配到函数中 定义
的类型形参时，可以让该类的值作为这些函数的实参传递，也可以作为这些函数的
返回值

你不能把任何类都变成协变的：这样不安全。让类在某个类型参数变为协变，
限制了该类中对该类型参数使用的可能性。要保证类型安全，它只能用在所谓的
out 位置，意味着这个类只能生产类型 T 的值而不能消费它们

在类成员的声明中类型参数的使用可以分为 in 位置和 out 位置。考虑这样一个
类，它声明了一个类型参数 T 并包含了一个使用 T 的函数。如果函数是把 T 当成返
回类型，我们说它在 out 位置。这种情况下，该函数生产类型为 T 的值 。 如果 T 用
作函数参数的类型，它就在 in 位置。这样的函数消费类型为 T 的值

类的类型参数前的 out 关键字要求所有使用 T 的方法只能把 T 放在 out 位置
而不能放在川位置。这个关键宇约束了使用 T 的可能性，这保证了对应子类型关
系的安全性。

类型参数 T 上的关键宇 out 有两层含义：
· 子类型化会被保留（ Producer<Cat ＞是 Producer <Anirnal ＞ 的子类型）
• T 只能用在 out 位置

不能把 Mut able List <T＞在它 的类型参数上声明成协变的，因为它既
含有接收类型为 T 的值作为参数的方法，也含有返回这种值的方法（

注意，构造方法的参数既不在 in 位置，也不在 out 位置

对一个逆变类来说，它的子类型化关系
与用作类型实参的类的子类型化关系是相反的

一个为特定类型的值定义的比较器显然可以比较该类型任意子类型的值。例如，
如果有一个 Comparator<Any＞，可以用它比较任意具体类型的值 。
如果你要在特定
类型的对象上执行比较，可以使用能处理该类型或者它的超类型的比较器。这说明
Comparator<Any＞是 Comparator<String＞的子类型，其中 Any 是 String
的超类型

一个在类型参数上逆变的类是
这样的一个泛型类（我们以 Consumer<T＞为例），对这种类来说
如果 B 是 A 的子类型，那么 Co口sumer<A＞就是 Consumer<B＞的
子类型

in 关键字的意思是，对应类型的值是传递进来给这个类的方法的，并且被这
些方法消费

在类声 明的时候就能够指定变型修饰符是很方便的，因为这些修饰符会应用
到所有类被使用 的地方。这被称作声明点 变 型

Kotlin 的使用点 变型直接对应 Java 的眼界通配符 。 Kotiin 中的
MutableList<out T＞ 和 Java 中的 MutableList<? extends T>
是一个意思。 in 投影的 MutableList<in T＞对应到 Java 的
MutableList<? super T ＞

Kotlin 的 MyType＜女＞对应于 Java 的 MyType ＜？＞

当类型实参的信息并不重要的时候，可以使用星号投影的语法：不需要使用任
何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型。
星号投影的语法很简沽，但只能用在对泛型类型实参的确切值不感兴趣的地方：
只是使用生产值的方法，而且不关心那些值的类型。


把不安全的代码局部化
到一个分开的位置预防了误用，而且让容器的使用变得安全

在 Kotlin 中既可以为整个泛型类指定变型（声明点变型） ，也可以为泛型类
型特定的使用指定变型（使用点变型）。

注解和反射给你
超越这个规则的能力，并让你编写出使用事先未知的任意类的代码
可以使用注解
赋予这些类库特定的语义，而反射允许你在运行时分析这些类的结构。

一个注解允许你把额外的
元数据关联到一个声明上。然后元数据就可以被相关的源代码工具访问，通过编译
好的类文件或是在运行时， 取决于这个注解是如何配置的

注解实参需要在编译期就是己知的，所以你不能引用任意的属性作为实参
要
把属性当作注解实参使用，你需要用 con st 修饰符标记它，来告知编译器这个属
性是编译期常量

指定注解实参的语法:
a.要把一 个类指定为注解实参，在类名后加上 ： ： class : @MyAnnotation
(MyClass: : class ） 。
b.要把另 一个 注解指定为一 个实参 ， 去掉注解名称前面的＠，想ReplaceWith
c.要把一个数纽指定为一个实参，使用 arrayOf 函数：＠ RequestMapping
(path = arrayOf ("I foo勺 " /bar”）


使用点目标声明被用来说明要注解的元素。使用点目标被放在＠符号和注解名
称之间，并用冒号和注解名称隔开。图 10. l 中的单词 get 导致注解＠ Rule 被应用
到了属性的 ge阳r 上。
@get:Rule

应用到 file 目标的注解都必须放在文件的顶层 ，放在 package 指令之前。
如@JvmName
@JvmName 将改变由 Kotlin 生成的 Java 方法或字段的名称 。
·• @JvmStatic 能被用在对象声明或者伴生对象的方法上，把它们暴露成
Java 的静态方法 。
• @JvmOverloads ，曾在 3.2.2 节中出现过，指导 Kotlin 编译器为带默认
参数值的函数生成多个重载（函数）。
• @JvmField 可以应用于一个属性，把这个属性暴露成一个没有访问器的
公有 Java 字段。

https: //manning .comlbooks/kotlin-in-action 和 http: //github.com/yol的kid

因为注解类只是用来定义关联到声明和表达式的元数据的结
构，它们不能包含任何代码

可以应用到注解类上的注
解被称作元注解
许多依赖注入库使用了元注解来标记其他
注解，表示这些注解用来识别拥有同样类型的不同的可注入对象。

Java 默认会在 .class 文件中保留注解但不会让它们在运行时被访问到 。
大多 数注解确 实 需要在运行时存在，所以 Kotlin 的默认行为不同：注解拥有
RUNTI ME 保 留期


KC lass 是 Java 的 j ava .l ang . Class 类型在 Kotlin 中的对应类型
用来
保存 Kotiin 类的引用

KClass<out Any>  <--  KClass<CompanyImple>
类型 Companyimpl: : class (KClass <Companyimpl ＞ ）是类型(KClass <out A叮〉）的子类型
out 关键
字说明允许引 用那些继承 Any 的类，而不仅仅是引用 Any 自己


反射是，简单来说，一种在运行时动态地访问对象属性和方法的方式，而不需
要事先确定这些属性是什么

KClass ，它代表了 一个类 。 KClass 对应的
是 j ava . lang . class

注解类的声明是这样的，它是一个拥有主构造方法且没有类主体的类，其构
造方法中所有参数都被标记成 val 属性。

要获取 一 个 KClass 的实例，如果类是静态己知的，可以使用
ClassName::class ：否则，使用 obj.javaClass . kotlin 从对象实例
上取得类 。


KFunction 接口和 KProperty 接口都继承了 KCallable ，它提供了 －个
通用的 call 方法 。
• KCallable. callBy 方法能用来调用带默认参数值的方法 。
• KFuncti o nO 、 KFunctionl 等这种不同参数数量的函数可以使用 inv o ke
方法调用 。
• KPropertyO 和 KPropertyl 是接收者数量不同的属性，支持用 get 方法
取回值 。 KMutablePropertyO 和 KMutablePropertyl 继承了这些接口，
支持通过 set 方法来改变属性的值。


使用领域特定语言 CDSL ）为你的 Kotlin 类设计更
有表现力、更符合语言 习惯的 API

DSL 风格的 API 被广泛地应用于各个领域的许多不同的实际问题当
中，诸如数据库访问、 HTML 生成、测试、编写编译脚本、定义 Android UI 布局，等等。

目标是尽可能地让代码具有最佳的可读性和可维护性

需要
关注交互发生的接口一一换句话说就是类的 API

确保这些交互易于理解并可以清楚地表达，对保持
项目的可维护性至关重要。

一个 API 是整洁
它需要能够让读者清楚地知道在代码中发生了什么 。这可 以通过选择良好的
名称和概念来做到 ，这对任何语言来说都很重要。
· 代码需要看起来整洁，极少使用浮夸的代码且不存在 多余 的语法

Kotlin 允许你构建整洁 API 的功能的代表包括 ：扩展函数、中缀调用、 lambda
简明语法和运算符重载

Kotlin 的 DSL 建立在那些整洁语法的特性上，利用由多个方法调用创建出结构的能
力来扩展它们 。 因此， DSL 比由单独方法构造出的 API 更具表现力并且更适直工作


Kotiin 的 DSL 是完全静态类型的

将通用编程语言
（有一系列足够完善的能力来解决几乎所有能被计算机解决的问题）与领域特定语
言（专注在特定任务，或者说领域上，并放弃与该领域无关的功能）区分开来

最常见的 DSL 就是 SQL 和正则表达式。它们分别很好地解
决了操作数据库和文本字符串的特定任务，但是你不能用它们来开发整个应用程序

这些语言可以通过减少它们提供的功能来有效地完成它们的目标
通过这样
紧凑的语法， DSL 能够比通用编程语言中的等价代码更简洁地表达特定领域的操作

DSL 更趋向于声明式，和通用编程语言相反，它们大部分是命令
式的。命令式语言描述了执行操作所需步骤的确切序列，而声 明式语言描述了想要
的结果并将执行细节留给了解释它的引擎

内部 DSL 不是完全
独立的语言，而是使用主要语言的特定方式，同时保留具有独立语法的 DSL 的主要
优点。

DSL
中经常会出现一个通常在其他 API 中不存在的特征：结构或者说是文法

DSL 的方法调用存在于由 DSL 文法定义的
更大的结构中

在 Kotlin DSL 中，结构通常是通过嵌套的 lambda 表达式或链式方
法调用来创建的。

这种文法使得我们能够将一个内部 DSL 称作一 门语言 。在一 门像英语这样的自
然语言中，句子就是用单词构成的，而文法规则控制着这些单词之间如何组合

DSL 结构的 一个好处就是允许你在多个函数调用之 间重用 一个上下文，而不
是在每一次调用时都去重复它


构建kotlin项目：
对于现有的maven项目，tools->kotlin->configure kotlin添加对kotlin的支持
手动给kotlin项目添加maven支持，
依赖kotlin-stdlib
插件kotlin-maven-plugin并配置compile和test-compile

kotlin 的文档生成工具叫作 Dokka: https ://github.com/kotlin/dokka






















































